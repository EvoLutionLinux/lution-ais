#!/bin/bash
#
# Lution-AIS installer (version 0.4.15 - 14th January 2015)
#
# Written by Carl Duff for Evo/Lution Linux
#
# Some code has been used or adapted from the Arch Installation Script (AIS)
# and Arch Ultimate Installer (AUI) written by helmuthdu, the Antergos 
# CLI installer written by Alex Filgueira, and the Manjaro 0.8 installer
# Written by Philip Muller.
#
# This program is free software, provided under the GNU General Public License
# as published by the Free Software Foundation. So feel free to copy, distribute,
# or modify it as you wish.
#

# Current Script details
SCRIPT="$(basename $0)"
pushd "$(dirname $0)" >/dev/null
SCRIPT_DIR="$(pwd -P)"
popd >/dev/null
PWD="$(pwd -P)"

# Make sure the script is run from its proper path.
# OR Since we know the path, why don't we do it ourselves ?
if [ $PWD != $SCRIPT_DIR ]
then
    echo "Run the script from the lution-ais directory like:"
    echo "cd $SCRIPT_DIR && ./$SCRIPT"
    exit 1
fi

######################################################################
##																	##
##                   Installer Variables							##
##																	##
######################################################################

# Create a temporary file to store menu selections
ANSWER="/tmp/.lution"

# Save retyping
VERSION="Lution-AIS 0.4.15 (14-Jan-2015)"

# Installation
KDE_INSTALLED=0      		# Has KDE been installed? Used for display manager option
PLASMA_INSTALLED=0    		# Has Plasma 5 been installed? Used for display manager option
GNOME_INSTALLED=0    		# Has Gnome been installed? Used for display manager option
LXDE_INSTALLED=0     		# Has LXDE been installed? Used for display manager option
DM_INSTALLED=0       		# Has a display manager been installed?
COMMON_INSTALLED=0   		# Has the common-packages option been taken?
NM_INSTALLED=0       		# Has a network connection manager been installed and enabled?
AXI_INSTALLED=0             # Have the ALSA, Xorg, and xf86-input packages been installed?
BOOTLOADER="n/a"      		# Which bootloader has been installed?
EVOBOXFM=""           		# Which file manager has been selected for EvoBox?
EVOBOXIB=""           		# Which Internet Browser has been selected for EvoBox?
DM="n/a"              		# Which display manager has been installed?
KEYMAP="us"          		# Virtual console keymap. Default is "us"
XKBMAP="us"      	    	# X11 keyboard layout. Default is "us"
ZONE=""               		# For time
SUBZONE=""            		# For time
LOCALE="en_US.UTF-8"  		# System locale. Default is "en_US.UTF-8"
LTS=0                		# Has the LTS Kernel been installed?
GRAPHIC_CARD=$(hwinfo --gfxcard | grep 'Model')  # Auto-detect popular graphics cards
GC_DETECTED=""        		# Name of Graphics Card Detected
NVIDIA_INST=0         		# Indicates if NVIDIA proprietary driver has been installed
SHOW_ONCE=0           		# Show de_wm information only once

# Architecture
ARCHI=`uname -m`     		# Display whether 32 or 64 bit system
UEFI=0               		# Is the system UEFI?
SYSTEM="Unknown"     		# Display whether system is BIOS or UEFI. Default is "unknown"
ROOT_PART=""          		# ROOT partition
UEFI_PART=""				# UEFI partition
UEFI_MOUNT=""         		# UEFI mountpoint
INST_DEV=""           		# Device where system has been installed
HIGHLIGHT=0           		# Highlight items for Main Menu
HIGHLIGHT_SUB=0	    		# Highlight items for submenus
SUB_MENU=""           		# Submenu to be highlighted

# Logical Volume Management
LVM=0                   	# Logical Volume Management Detected?
LUKS=0                  	# Luks Detected?
LVM_ROOT=0              	# LVM used for Root?
LVM_SEP_BOOT=0          	# 1 = Seperate /boot, 2 = seperate /boot & LVM
LVM_DISABLE=0           	# Option to allow user to deactive existing LVM
LVM_VG=""               	# Name of volume group to create
LVM_VG_MB=0             	# MB remaining of VG
LVM_LV_NAME=""          	# Name of LV to create
LV_SIZE_INVALID=0       	# Is LVM LV size entered valid?
VG_SIZE_TYPE=""         	# Is VG in Gigabytes or Megabytes?

# Installation
MOUNTPOINT="/mnt"       	# Installation
MOUNT_TYPE=""           	# "/dev/" for standard partitions, "/dev/mapper" for LVM

# Language Support
EVO_LOCALE="en_US.UTF-8"    # Default Evo Locale

# Edit Files
FILE=""                     # Which file is to be opened?
FILE2=""                    # Some configs use two files. Not using an array.

######################################################################
##																	##
##                        Core Functions							##
##																	##
######################################################################

# Add locale on-the-fly and sets source translation file for installer
select_language() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Select Language " --menu "\nLanguage / sprache / taal / nγλώσσα / språk / lingua / idioma / язык / język / nyelv / língua" 22 30 11 \
 	"1" $"English" \
 	"2" $"Deutsch" \
 	"3" $"Nederlands" \
 	"4" $"Eλληνικά" \
 	"5" $"Norsk" \
 	"6" $"Italiano" \
 	"7" $"Español" \
 	"8" $"Русский" \
 	"9" $"Polski" \
 	"10" $"Magyar" \
 	"11" $"Portugese" 2>${ANSWER}

	case $(cat ${ANSWER}) in
        "1") source $SCRIPT_DIR/english.trans
             EVO_LOCALE="en_US.UTF-8"
             ;;
        "2") source $SCRIPT_DIR/german.trans
             EVO_LOCALE="de_DE.UTF-8" 
             ;;
        "3") source $SCRIPT_DIR/dutch.trans
             EVO_LOCALE="nl_NL.UTF-8"
             ;;
        "4") source $SCRIPT_DIR/greek.trans
             EVO_LOCALE="el_GR.UTF-8"
             ;;
        "5") source $SCRIPT_DIR/norwegian.trans
             EVO_LOCALE="nl_NL.UTF-8"
             ;;
        "6") source $SCRIPT_DIR/italian.trans
             EVO_LOCALE="it_IT.UTF-8"
             ;;
        "7") source $SCRIPT_DIR/spanish.trans
             EVO_LOCALE="es_ES.UTF-8"
             ;;
        "8") source $SCRIPT_DIR/russian.trans
             EVO_LOCALE="ru_RU.UTF-8"
             ;;
        "9") source $SCRIPT_DIR/polish.trans
             EVO_LOCALE="pl_PL.UTF-8"
             ;;
       "10") source $SCRIPT_DIR/hungarian.trans
             EVO_LOCALE="hu_HU.UTF-8"  
             ;;
       "11") source $SCRIPT_DIR/portuguese.trans
             EVO_LOCALE="pt_PT.UTF-8"
             ;;
          *) exit 0
             ;;
    esac
        
    # Generate the chosen locale and set the language
    sed -i "s/#${EVO_LOCALE}/${EVO_LOCALE}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG=${EVO_LOCALE}

}



# Check user is root, and that there is an active internet connection
# Seperated the checks into seperate "if" statements for readability.
check_evo_requirements() {
	
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ChkEvoTitle" --infobox "$_ChkEvoBody" 0 0
  sleep 2
  
  if [[ `whoami` != "root" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RtFailTitle" --infobox "$_RtFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  if [[ ! $(ping -c 1 google.com) ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConFailTitle" --infobox "$_ConFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  # This will only be executed where neither of the above checks are true.
  # The error log is also cleared, just in case something is there from a previous use of the installer.
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ReqMetTitle" --infobox "$_ReqMetBody" 0 0
  sleep 2   
  clear
  echo "" > /tmp/.errlog
  pacman -Syy

}

# Adapted from AIS. Checks if system is made by Apple, whether the system is BIOS or UEFI,
# and for LVM and/or LUKS.
id_system() {
	
    # Apple System Detection
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    
    # BIOS or UEFI Detection
    if [[ -d "/sys/firmware/efi/" ]]; then
      # Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      UEFI=1
      SYSTEM="UEFI"
    else
      UEFI=0
      SYSTEM="BIOS"
    fi
         
    # Encryption (LUKS) Detection
    [[ $(lsblk -o TYPE | grep "crypt") == "" ]] && LUKS=0 || LUKS=1

}   
 

# Adapted from AIS. An excellent bit of code!
arch_chroot() {
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
}  

# If there is an error, display it, clear the log and then go back to the main menu (no point in continuing).
check_for_error() {

 if [[ $? -eq 1 ]] && [[ $(cat /tmp/.errlog | grep -i "error") != "" ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$(cat /tmp/.errlog)" 0 0
    echo "" > /tmp/.errlog
    main_menu_online
 fi
   
}

# Ensure that a partition is mounted
check_mount() {

    if [[ $(ls ${MOUNTPOINT}) == "" ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoMount" 0 0
       main_menu_online
    fi

}

# Ensure that Arch has been installed
check_base() {

    if [[ ! -e ${MOUNTPOINT}/etc ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoBase" 0 0
        main_menu_online
    fi
    
}

# Simple code to show devices / partitions.
show_devices() {
     lsblk -o NAME,MODEL,TYPE,TRAN,FSTYPE,SIZE | grep -v "loop" | grep -v "rom" | grep -v "arch_airootfs" > /tmp/.devlist
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevShowTitle" --textbox /tmp/.devlist 0 0
}

######################################################################
##																	##
##                 Configuration Functions							##
##																	##
######################################################################


# Adapted from AIS. Added option to allow users to edit the mirrorlist.
configure_mirrorlist() {

# Generate a mirrorlist based on the country chosen.	
mirror_by_country() {

 COUNTRY_LIST=""
 countries_list=("AU_Australia AT_Austria BY_Belarus BE_Belgium BR_Brazil BG_Bulgaria CA_Canada CL_Chile CN_China CO_Colombia CZ_Czech_Republic DK_Denmark EE_Estonia FI_Finland FR_France DE_Germany GB_United_Kingdom GR_Greece HU_Hungary IN_India IE_Ireland IL_Israel IT_Italy JP_Japan KZ_Kazakhstan KR_Korea LV_Latvia LU_Luxembourg MK_Macedonia NL_Netherlands NC_New_Caledonia NZ_New_Zealand NO_Norway PL_Poland PT_Portugal RO_Romania RU_Russia RS_Serbia SG_Singapore SK_Slovakia ZA_South_Africa ES_Spain LK_Sri_Lanka SE_Sweden CH_Switzerland TW_Taiwan TR_Turkey UA_Ukraine US_United_States UZ_Uzbekistan VN_Vietnam")

 for i in ${countries_list}; do
     COUNTRY_LIST="${COUNTRY_LIST} ${i} -"
 done
	
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorCntryTitle" --menu "$_MirrorCntryBody" 0 0 16 ${COUNTRY_LIST} 2>${ANSWER} || prep_menu
 COUNTRY_CODE=$(cat ${ANSWER} |sed 's/_.*//')

 URL="https://www.archlinux.org/mirrorlist/?country=${COUNTRY_CODE}&use_mirror_status=on"
 MIRROR_TEMP=$(mktemp --suffix=-mirrorlist)

 # Get latest mirror list and save to tmpfile
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorGenTitle" --infobox "$_MirrorGenBody" 0 0
  
 curl -so ${MIRROR_TEMP} ${URL} 2>/tmp/.errlog
 check_for_error
 sed -i 's/^#Server/Server/g' ${MIRROR_TEMP}
 leafpad ${MIRROR_TEMP}

 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_MirrorGenQ" 0 0

 if [[ $? -eq 0 ]];then
    mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
    mv -f ${MIRROR_TEMP} /etc/pacman.d/mirrorlist
    chmod +r /etc/pacman.d/mirrorlist
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --msgbox "$_MirrorGenDone" 0 0
 else
    prep_menu
 fi
}

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorlistTitle" \
    --menu "$_MirrorlistBody" 0 0 2 \
	"1" "$_MirrorbyCountry" \
	"2" "$_MirrorEdit" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") mirror_by_country
             ;;
        "2") gksu leafpad /etc/pacman.d/mirrorlist
             ;;
          *) prep_menu
             ;;
    esac  	

}

# virtual console keymap
set_keymap() { 
	
	KEYMAPS=""
    for i in $(localectl --no-pager list-keymaps); do
        KEYMAPS="${KEYMAPS} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_KeymapTitle" \
    --menu "$_KeymapBody" 20 40 16 ${KEYMAPS} 2>${ANSWER} || config_base_menu
    KEYMAP=$(cat ${ANSWER})
    echo "KEYMAP=$KEYMAP" > ${MOUNTPOINT}/etc/vconsole.conf 2>/tmp/.errlog
    check_for_error
  }

# Set keymap for X11
 set_xkbmap() {
	 
	XKBMAP_LIST=""
	keymaps_xkb=("af_Afghani al_Albanian am_Armenian ara_Arabic at_German-Austria az_Azerbaijani ba_Bosnian bd_Bangla be_Belgian bg_Bulgarian br_Portuguese-Brazil bt_Dzongkha bw_Tswana by_Belarusian ca_French-Canada cd_French-DR-Congo ch_German-Switzerland cm_English-Cameroon cn_Chinese cz_Czech de_German dk_Danishee_Estonian epo_Esperanto es_Spanish et_Amharic fo_Faroese fi_Finnish fr_French gb_English-UK ge_Georgian gh_English-Ghana gn_French-Guinea gr_Greek hr_Croatian hu_Hungarian ie_Irish il_Hebrew iq_Iraqi ir_Persian is_Icelandic it_Italian jp_Japanese ke_Swahili-Kenya kg_Kyrgyz kh_Khmer-Cambodia kr_Korean kz_Kazakh la_Lao latam_Spanish-Lat-American lk_Sinhala-phonetic lt_Lithuanian lv_Latvian ma_Arabic-Morocco mao_Maori md_Moldavian me_Montenegrin mk_Macedonian ml_Bambara mm_Burmese mn_Mongolian mt_Maltese mv_Dhivehi ng_English-Nigeria nl_Dutch no_Norwegian np_Nepali ph_Filipino pk_Urdu-Pakistan pl_Polish pt_Portuguese ro_Romanian rs_Serbian ru_Russian se_Swedish si_Slovenian sk_Slovak sn_Wolof sy_Arabic-Syria th_Thai tj_Tajik tm_Turkmen tr_Turkish tw_Taiwanese tz_Swahili-Tanzania ua_Ukrainian us_English-US uz_Uzbek vn_Vietnamese za_English-S-Africa")
    
	for i in ${keymaps_xkb}; do
        XKBMAP_LIST="${XKBMAP_LIST} ${i} -"
    done
	
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_XkbmapTitle" --menu "$_XkbmapBody" 0 0 16 ${XKBMAP_LIST} 2>${ANSWER} || prep_menu
    XKBMAP=$(cat ${ANSWER} |sed 's/_.*//')
    echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${XKBMAP}"\"\nEndSection" > /tmp/00-keyboard.conf
    setxkbmap $XKBMAP 2>/tmp/.errlog
    check_for_error
 
}

# locale array generation code adapted from the Manjaro 0.8 installer
set_locale() {

  LOCALES=""	
  for i in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do
      LOCALES="${LOCALES} ${i} -"
  done

  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LocateTitle" --menu "$_localeBody" 0 0 16 ${LOCALES} 2>${ANSWER} || config_base_menu 
  LOCALE=$(cat ${ANSWER})
  
  echo "LANG=\"${LOCALE}\"" > ${MOUNTPOINT}/etc/locale.conf
  sed -i "s/#${LOCALE}/${LOCALE}/" ${MOUNTPOINT}/etc/locale.gen 2>/tmp/.errlog
  arch_chroot "locale-gen" >/dev/null 2>>/tmp/.errlog
  check_for_error
}

# Set Zone and Sub-Zone
set_timezone() {

    ZONE=""
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "/" | sed "s/\/.*//g" | sort -ud); do
      ZONE="$ZONE ${i} -"
    done
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeZTitle" --menu "$_TimeZBody" 0 0 10 ${ZONE} 2>${ANSWER} || config_base_menu
     ZONE=$(cat ${ANSWER}) 
    
     SUBZONE=""
     for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "${ZONE}/" | sed "s/${ZONE}\///g" | sort -ud); do
        SUBZONE="$SUBZONE ${i} -"
     done
         
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeSubZTitle" --menu "$_TimeSubZBody" 0 0 11 ${SUBZONE} 2>${ANSWER} || config_base_menu
     SUBZONE=$(cat ${ANSWER}) 
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_TimeZQ ${ZONE}/${SUBZONE} ?" 0 0 
     
     if [[ $? -eq 0 ]]; then
        arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" 2>/tmp/.errlog
        check_for_error
     else
        config_base_menu
     fi
}

set_hw_clock() {
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HwCTitle" \
    --menu "$_HwCBody" 0 0 2 \
 	"1" "$_HwCUTC" \
	"2" "$_HwLocal" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") arch_chroot "hwclock --systohc --utc"  2>/tmp/.errlog
             ;;
        "2") arch_chroot "hwclock --systohc --localtime" 2>/tmp/.errlog
             ;;
          *) config_base_menu
             ;;
     esac	
     
     check_for_error
}

# Adapted from AIS. As with some other functions, decided that keeping the numbering for options
# was worth repeating portions of code.
generate_fstab() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FstabTitle" \
    --menu "$_FstabBody" 0 0 3 \
	"1" "$_FstabDev" \
	"2" "$_FstabLabel" \
	"3" "$_FstabUUID" 2>${ANSWER}

    case $(cat ${ANSWER}) in
        "1") genfstab -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "2") genfstab -L -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "3") if [[ $UEFI -eq 1 ]]; then
                genfstab -t PARTUUID -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             else 
                genfstab -U -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             fi
             ;;
          *) config_base_menu
             ;;
    esac

    check_for_error

    [[ -f ${MOUNTPOINT}/swapfile ]] && sed -i "s/\\${MOUNTPOINT}//" ${MOUNTPOINT}/etc/fstab

}

# Adapted from AIS.
set_hostname() {

   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HostNameTitle" --inputbox "$_HostNameBody" 0 0 "evo" 2>${ANSWER} || config_base_menu
   HOST_NAME=$(cat ${ANSWER})

   echo "$HOST_NAME" > ${MOUNTPOINT}/etc/hostname 2>/tmp/.errlog
   check_for_error
   sed -i "/127.0.0.1/s/$/ ${HOST_NAME}/" ${MOUNTPOINT}/etc/hosts
   sed -i "/::1/s/$/ ${HOST_NAME}/" ${MOUNTPOINT}/etc/hosts
}

# Adapted and simplified from the Manjaro 0.8 and Antergos 2.0 installers
set_root_password() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD=$(cat ${ANSWER})
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody2" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD2=$(cat ${ANSWER})
    
    if [[ $PASSWD == $PASSWD2 ]]; then 
       echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
       arch_chroot "passwd root" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
       rm /tmp/.passwd
       check_for_error
    else
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtErrTitle" --msgbox "$_PassRtErrBody" 0 0
       set_root_password
    fi

}

# Originally adapted from the Antergos 2.0 installer
create_new_user() {

        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrBody" 0 0 "" 2>${ANSWER} || config_user_menu
        USER=$(cat ${ANSWER})
        
        # Loop while user name is blank, has spaces, or has capital letters in it.
         while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $(echo $USER | sed "s/[[:lower:]]//g") != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrErrBody" 0 0 "" 2>${ANSWER} || config_user_menu
              USER=$(cat ${ANSWER})
        done
        
        # Enter password. This step will only be reached where the loop has been skipped or broken.
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD=$(cat ${ANSWER}) 
    
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD2=$(cat ${ANSWER}) 
    
        # loop while passwords entered do not match.
        while [[ $PASSWD != $PASSWD2 ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrErrTitle" --msgbox "$_PassNUsrErrBody" 0 0
              
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD=$(cat ${ANSWER}) 
    
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD2=$(cat ${ANSWER}) 
        done      
    
        # create new user. This step will only be reached where the password loop has been skipped or broken.  
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrSetTitle" --infobox "$_NUsrSetBody" 0 0
        sleep 2
        # Create the user, set password, then remove temporary password file
        arch_chroot "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash" 2>/tmp/.errlog
        check_for_error
        echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
        arch_chroot "passwd ${USER}" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
        rm /tmp/.passwd
        check_for_error
        # Set up basic configuration files and permissions for user
        arch_chroot "cp /etc/skel/.bashrc /home/${USER}"
        arch_chroot "chown -R ${USER}:users /home/${USER}"
        sed -i '/%wheel ALL=(ALL) ALL/s/^#//' ${MOUNTPOINT}/etc/sudoers
      
}

run_mkinitcpio() {
	
  clear
  
  # If $LVM is being used, add the lvm2 hook
  [[ $LVM -eq 1 ]] && sed -i 's/block filesystems/block lvm2 filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf
    
  # Amend command depending on whether LTS kernel was installed or not
  [[ $LTS -eq 1 ]] && arch_chroot "mkinitcpio -p linux-lts" 2>/tmp/.errlog || arch_chroot "mkinitcpio -p linux" 2>/tmp/.errlog
  check_for_error
 
}

######################################################################
##																	##
##            System and Partitioning Functions						##
##																	##
######################################################################



# Unmount partitions.
umount_partitions(){
	
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  
  for i in ${MOUNTED[@]}; do
      umount $i >/dev/null 2>>/tmp/.errlog
  done
  
  check_for_error

}

# Adapted from AIS
confirm_mount() {
    if [[ $(mount | grep $1) ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusSucc" 0 0
      sleep 2
      PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
      NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusFail" 0 0
      sleep 2
      prep_menu
    fi
}

# Adapted from AIS. However, this does not assume that the formatted device is the Root
# installation device; more than one device may be formatted. This is now set in the
# mount_partitions function, when the Root is chosen.
select_device() {
	
    DEVICE=""
    devices_list=$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd');
    
    for i in ${devices_list[@]}; do
        DEVICE="${DEVICE} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevSelTitle" --menu "$_DevSelBody" 0 0 4 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(cat ${ANSWER})
 
  }

# Same as above, but goes to install_base_menu instead where cancelling, and otherwise installs Grub.
select_grub_device() {
	
    GRUB_DEVICE=""
    grub_devices_list=$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd');
    
    for i in ${grub_devices_list[@]}; do
        GRUB_DEVICE="${GRUB_DEVICE} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevSelGrubTitle" --menu "$_DevSelBody" 0 0 4 ${GRUB_DEVICE} 2>${ANSWER} || install_base_menu
    GRUB_DEVICE=$(cat ${ANSWER})
    clear
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
    sleep 1
    arch_chroot "grub-install --target=i386-pc --recheck ${GRUB_DEVICE}" 2>/tmp/.errlog
    check_for_error
 
  }

# Originally adapted from AIS.
create_partitions(){

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PartToolTitle" \
    --menu "$_PartToolBody" 0 0 4 \
 	"1" $"GParted (GUI - BIOS & UEFI)" \
	"2" $"CFDisk  (CLI - BIOS/MBR)" \
	"3" $"CGDisk  (CLI - UEFI/GPT)" \
	"4" $"GDisk   (CLI - UEFI/GPT)" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") gparted ${DEVICE} >/dev/null 2>&1
             ;;
        "2") cfdisk ${DEVICE}
             ;;
        "3") cgdisk ${DEVICE}
             ;;       
        "4") gdisk ${DEVICE}
             ;;
          *) prep_menu
             ;;
    esac  	
}	

# find all available partitions and generate a list of them
# This also includes partitions on different devices.
find_partitions() {

	PARTITIONS=""
	NUMBER_PARTITIONS=0
    partition_list=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	
    for i in ${partition_list[@]}; do
        PARTITIONS="${PARTITIONS} ${i} -"
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done
    
    # Deal with incorrect partitioning
    if [[ $NUMBER_PARTITIONS -lt 2 ]] && [[ $UEFI -eq 1 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_UefiPartErrTitle" --msgbox "$_UefiPartErrBody" 0 0
        create_partitions
    fi
    
    if [[ $NUMBER_PARTITIONS -eq 0 ]] && [[ $UEFI -eq 0 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_BiosPartErrTitle" --msgbox "$_BiosPartErrBody" 0 0	
        create_partitions
    fi
}

# Set static list of filesystems rather than on-the-fly. Partially as most require additional flags, and 
# partially because some don't seem to be viable.
select_filesystem(){

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FSTitle" \
    --menu "$_FSBody" 0 0 11 \
 	"1" "$_FSSkip" \
	"2" $"ext2" \
 	"3" $"ext3" \
	"4" $"ext4" \
	"5" $"f2fs" \
	"6" $"jfs" \
 	"7" $"nilfs2" \
	"8" $"ntfs" \
	"9" $"reiserfs" \
 	"10" $"vfat" \
	"11" $"xfs" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") FILESYSTEM="skip"
             ;;
        "2") FILESYSTEM="mkfs.ext2 -F"
             ;;
        "3") FILESYSTEM="mkfs.ext3 -F"
             ;;            
        "4") FILESYSTEM="mkfs.ext4 -F"
             ;;
        "5") FILESYSTEM="mkfs.f2fs"
             modprobe f2fs
             ;;
        "6") FILESYSTEM="mkfs.jfs -q"
             ;;
        "7") FILESYSTEM="mkfs.nilfs2 -f"
             ;;  
        "8") FILESYSTEM="mkfs.ntfs -q"
             ;;  
        "9") FILESYSTEM="mkfs.reiserfs -f -f"
             ;;  
       "10") FILESYSTEM="mkfs.vfat -F32"
             ;;  
       "11") FILESYSTEM="mkfs.xfs -f"
             ;;      
          *) prep_menu
             ;;
    esac

  }
  
mount_partitions() {

# function created to save repitition of code. Checks and determines if standard partition or LVM LV,
# and sets the prefix accordingly.
set_mount_type() {

[[ $(echo ${PARTITION} | grep 'sd\|hd\|vd[a-z][1-99]') != "" ]] && MOUNT_TYPE="/dev/" || MOUNT_TYPE="/dev/mapper/"
	
}

    # LVM Detection. If detected, activate.
    detect_lvm
    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --infobox "$_LvmDetBody2" 0 0
       sleep 2   
       modprobe dm-mod 2>/tmp/.errlog
       check_for_error
       vgscan >/dev/null 2>&1
       vgchange -ay >/dev/null 2>&1
    fi

	# Ensure partitions are unmounted (i.e. where mounted previously), and then list available partitions
    umount_partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelRootTitle" --menu "$_SelRootBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || prep_menu
	PARTITION=$(cat ${ANSWER})
    ROOT_PART=${PARTITION}
    set_mount_type
    
    # This is to identify the device for Grub installations.
    if [[ $MOUNT_TYPE == "/dev/" ]]; then   
       LVM_ROOT=0
       INST_DEV=${MOUNT_TYPE}$(cat ${ANSWER} | sed 's/[0-9]*//g')
    else
       LVM_ROOT=1
    fi
    	
	select_filesystem
	[[ $FILESYSTEM != "skip" ]] && ${FILESYSTEM} ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
	check_for_error
	
	mkdir -p ${MOUNTPOINT} 2>/tmp/.errlog
	mount ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT} 2>>/tmp/.errlog
	check_for_error
    confirm_mount ${MOUNTPOINT}
	
	# Identify and create swap, if applicable
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelSwpTitle" --menu "$_SelSwpBody" 0 0 4 "$_SelSwpNone" $"-" "$_SelSwpFile" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu  
    if [[ $(cat ${ANSWER}) != "$_SelSwpNone" ]]; then    
       PARTITION=$(cat ${ANSWER})
       
       if [[ $PARTITION == "$_SelSwpFile" ]]; then
          total_memory=`grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//'`
          fallocate -l ${total_memory}M ${MOUNTPOINT}/swapfile >/dev/null 2>/tmp/.errlog
          check_for_error
          chmod 600 ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          mkswap ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          swapon ${MOUNTPOINT}/swapfile >/dev/null 2>&1
       else
          set_mount_type
          mkswap  ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
          swapon  ${MOUNT_TYPE}${PARTITION} >/dev/null 2>>/tmp/.errlog
          check_for_error
          # Since a partition was used, remove that partition from the list
          PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
          NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
       fi
    fi
    
    # Extra Step for VFAT UEFI Partition. This cannot be in an LVM container.
    if [[ $UEFI -eq 1 ]]; then
    
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelUefiTitle" --menu "$_SelUefiBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || config_base_menu  
       PARTITION=$(cat ${ANSWER})
       UEFI_PART=$"/dev/"${PARTITION}
       
       # If it is already a fat/vfat partition...
       if [[ $(fsck -N /dev/$PARTITION | grep fat) ]]; then
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FormUefiTitle" --yesno "$_FormUefiBody $PARTITION $_FormUefiBody2" 0 0 && mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>/tmp/.errlog
       else 
          mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>/tmp/.errlog
       fi
       check_for_error
       
       # Inform users of the mountpoint options and consequences
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_OptUefiTitle" --msgbox "$_OptUefiBody" 0 0
       
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntUefiTitle" --menu "$_MntUefiBody"  0 0 2 \
 	   "1" $"/boot" \
	   "2" $"/boot/efi" 2>${ANSWER}
       
       case $(cat ${ANSWER}) in
        "1") UEFI_MOUNT="/boot"
             ;;
        "2") UEFI_MOUNT="/boot/efi"
             ;;
          *) config_base_menu
             ;;
       esac
       
       mkdir -p ${MOUNTPOINT}${UEFI_MOUNT} 2>/tmp/.errlog
       mount $"/dev/"${PARTITION} ${MOUNTPOINT}${UEFI_MOUNT} 2>>/tmp/.errlog
       check_for_error
       confirm_mount ${MOUNTPOINT}${UEFI_MOUNT}     
       
    fi
    
    # All other partitions
       while [[ $NUMBER_PARTITIONS > 0 ]]; do 
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtPartTitle" --menu "$_ExtPartBody" 0 0 4 "$_Done" $"-" ${PARTITIONS} 2>${ANSWER} || config_base_menu 
             PARTITION=$(cat ${ANSWER})
             set_mount_type
             
             if [[ $PARTITION == ${_Done} ]]; then
                break;
             else
                MOUNT=""
                
                select_filesystem 
                [[ $FILESYSTEM != "skip" ]] && ${FILESYSTEM} ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
	            check_for_error
	            
                # Don't give /boot as an example for UEFI systems!
                if [[ $UEFI -eq 1 ]]; then
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                else
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                fi
                MOUNT=$(cat ${ANSWER})
                
                # loop if the mountpoint specified is incorrect (is only '/', is blank, or has spaces). 
                while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtErrTitle" --msgbox "$_ExtErrBody" 0 0
                      
                      # Don't give /boot as an example for UEFI systems!
                      if [[ $UEFI -eq 1 ]]; then
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                      else
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                      fi
                      MOUNT=$(cat ${ANSWER})                     
                done

                # Create directory and mount. This step will only be reached where the loop has been skipped or broken.
                mkdir -p ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
                mount  ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
                check_for_error
                confirm_mount ${MOUNTPOINT}${MOUNT}
                
                # Determine if a seperate /boot is used, and if it is LVM or not
                LVM_SEP_BOOT=0
                if [[ $MOUNT == "/boot" ]]; then
                   [[ $MOUNT_TYPE == "/dev/" ]] && LVM_SEP_BOOT=1 || LVM_SEP_BOOT=2
                fi
                                  
             fi
       done
}	

######################################################################
##																	##
##             Logical Volume Management Functions			    	##
##																	##
######################################################################


# LVM Detection.
detect_lvm() {

  LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
  LVM_VG=$(vgs -o vg_name --noheading 2>/dev/null)
  LVM_LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
  
  if [[ $LVM_LV = "" ]] && [[ $LVM_VG = "" ]] && [[ $LVM_PV = "" ]]; then
     LVM=0
  else
     LVM=1
  fi
 
}

# Where existing LVM is found, offer to deactivate it. Code adapted from the Manjaro installer.
# NEED TO ADD COMMAND TO REMOVE LVM2 FSTYPE.
deactivate_lvm() {

 LVM_DISABLE=0

    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --yesno "$_LvmDetBody1" 0 0 \
       && LVM_DISABLE=1 || LVM_DISABLE=0
    fi
    
    if [[ $LVM_DISABLE -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmRmTitle" --infobox "$_LvmRmBody" 0 0
       sleep 2
       
        for i in ${LVM_LV}; do
            lvremove -f /dev/mapper/${i} >/dev/null 2>&1
        done

        for i in ${LVM_VG}; do
            vgremove -f ${i} >/dev/null 2>&1
        done

        for i in ${LV_PV}; do
            pvremove -f ${i} >/dev/null 2>&1
        done
        
        # This step will remove old lvm metadata on partitions where identified.
        LVM_PT=$(lvmdiskscan | grep 'LVM physical volume' | grep 'sd[a-z]' | sed 's/\/dev\///' | awk '{print $1}')
        for i in ${LVM_PT}; do
            dd if=/dev/zero bs=512 count=512 of=/dev/${i} >/dev/null 2>&1
        done
    fi

}

# Find and create a list of partitions that can be used for LVM. Partitions already used are excluded.
find_lvm_partitions() {

    LVM_PARTITIONS=""
    NUMBER_LVM_PARTITIONS=0
    lvm_partition_list=$(lvmdiskscan | grep -v 'LVM physical volume' | grep 'sd[a-z][1-99]' | sed 's/\/dev\///' | awk '{print $1}')
	
    for i in ${lvm_partition_list[@]}; do
        LVM_PARTITIONS="${LVM_PARTITIONS} ${i} -"
        NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS + 1 ))
    done
    
}

# This simplifies the creation of the PV and VG into a single step.
create_lvm() {

# subroutine to save a lot of repetition.
check_lv_size() {

  LV_SIZE_INVALID=0
  LV_SIZE_TYPE=$(echo ${LVM_LV_SIZE:$(( ${#LVM_LV_SIZE} - 1 )):1})
  chars=0
  
  # Check to see if anything was actually entered
  [[ ${#LVM_LV_SIZE} -eq 0 ]] && LV_SIZE_INVALID=1

  # Check if there are any non-numeric characters prior to the last one
  while [[ $chars -lt $(( ${#LVM_LV_SIZE} - 1 )) ]]; do
        if [[ ${LVM_LV_SIZE:chars:1} != [0-9] ]]; then
           LV_SIZE_INVALID=1
           break;
        fi
        chars=$(( chars + 1 ))
  done

  # Check to see if first character is '0'
  [[ ${LVM_LV_SIZE:0:1} -eq "0" ]] && LV_SIZE_INVALID=1

  # Check to see if last character is "G" or "M", and if so, whether the value is greater than
  # or equal to the LV remaining Size. If not, convert into MB for VG space remaining.      
  if [[ ${LV_SIZE_INVALID} -eq 0 ]]; then
      case ${LV_SIZE_TYPE} in
         "G") if [[ $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) ))
              fi
              ;;
         "M") if [[ $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) ))
              fi
              ;;
           *) LV_SIZE_INVALID=1
              ;;
      esac
  fi
      
}

	# Check that there is at least one partition available for LVM
    if [[ $NUMBER_LVM_PARTITIONS -lt 1 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPartErrTitle" --msgbox "$_LvmPartErrBody" 0 0
        prep_menu
    fi
    
    # Create a temporary file to store the partition(s) selected. This is later used for the vgcreate command. 'x' is used as a marker.
    echo "x" > /tmp/.vgcreate
    
    # Name the Volume Group
    LVM_VG=""
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
    LVM_VG=$(cat ${ANSWER})

    # Loop while the Volume Group name starts with a "/", is blank, has spaces, or is already being used
    while [[ ${LVM_VG:0:1} == "/" ]] || [[ ${#LVM_VG} -eq 0 ]] || [[ $LVM_VG =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_VG}) != "" ]]; do
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgErrTitle" --msgbox "$_LvmNameVgErr" 0 0
              
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
        LVM_VG=$(cat ${ANSWER})
    done
    
    # Select the first or only partition for the Volume Group
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
    LVM_PARTITION=$(cat ${ANSWER})
    
    # add the partition to the temporary file for the vgcreate command
    # Remove selected partition from the list and deduct number of LVM viable partitions remaining
    sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
    LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
    sleep 1

    # Where there are viable partitions still remaining, run loop
    while [[ $NUMBER_LVM_PARTITIONS -gt 0 ]]; do

           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 $"Done" $"-" ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
           LVM_PARTITION=$(cat ${ANSWER})

           if [[ $LVM_PARTITION == "Done" ]]; then
              break;
           else
              sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
              LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
              NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
              sleep 1
           fi

    done

    # Once all the partitions have been selected, remove 'x' from the .vgcreate file, then use it in 'vgcreate' command.
    # Also determine the size of the VG, to use for creating LVs for it.
    VG_PARTS=$(cat /tmp/.vgcreate | sed 's/x//')
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvConfTitle" --yesno "$_LvmPvConfBody1${LVM_VG} $_LvmPvConfBody2${VG_PARTS}" 0 0
    
    if [[ $? -eq 0 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvActTitle" --infobox "$_LvmPvActBody1${LVM_VG}.$_LvmPvActBody2" 0 0
       sleep 2
       vgcreate -f ${LVM_VG} ${VG_PARTS} >/dev/null 2>/tmp/.errlog
       check_for_error
       VG_SIZE=$(vgdisplay | grep 'VG Size' | awk '{print $3}' | sed 's/\..*//')
       VG_SIZE_TYPE=$(vgdisplay | grep 'VG Size' | awk '{print $4}' | sed 's/\..*//')
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvDoneTitle" --msgbox "$_LvmPvDoneBody1 '${LVM_VG}' $_LvmPvDoneBody2 (${VG_SIZE} ${VG_SIZE_TYPE}).\n\n" 0 0
       sleep 2
    else
       prep_menu
    fi

    # Convert the VG size into GB and MB. These variables are used to keep tabs on space available and remaining
    [[ ${VG_SIZE_TYPE:0:1} == "G" ]] && LVM_VG_MB=$(( VG_SIZE * 1000 )) || LVM_VG_MB=$VG_SIZE
    
    # Specify number of Logical volumes to create.
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
    NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    
    # Loop if the number of LVs is no 1-9 (including non-valid characters)
    while [[ $NUMBER_LOGICAL_VOLUMES != [1-9] ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumErrTitle" --msgbox "$_LvmLvNumErrBody" 0 0
 
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
          NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    done

    # Loop while the number of LVs is greater than 1. This is because the size of the last LV is automatic.
    while [[ $NUMBER_LOGICAL_VOLUMES -gt 1 ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
          LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
          LVM_LV_SIZE=$(cat ${ANSWER})          
          check_lv_size 
          
          # Loop while an invalid value is entered.
          while [[ $LV_SIZE_INVALID -eq 1 ]]; do
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeErrTitle" --msgbox "$_LvmLvSizeErrBody" 0 0
          
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
                LVM_LV_SIZE=$(cat ${ANSWER})          
                check_lv_size
          done
          
          # Create the LV
          lvcreate -L ${LVM_LV_SIZE} ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
          check_for_error
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvDoneTitle" --msgbox "\n$_Done\n\nLV ${LVM_LV_NAME} (${LVM_LV_SIZE}) $_LvmPvDoneBody2.\n\n" 0 0
          NUMBER_LOGICAL_VOLUMES=$(( NUMBER_LOGICAL_VOLUMES - 1 ))
    done
    
    # Now the final LV. Size is automatic.      
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
    LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

    # Create the final LV
    lvcreate -l +100%FREE ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
    check_for_error
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmCompTitle" --yesno "$_LvmCompBody" 0 0 \
    && show_devices || prep_menu
}

######################################################################
##																	##
##                    Installation Functions						##
##																	##
######################################################################	

install_base() {
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBseTitle" \
    --menu "$_InstBseBody" 0 0 4 \
 	"1" "$_InstBaseLK" \
	"2" "$_InstBaseLKBD" \
	"3" "$_InstBaseLTS" \
	"4" "$_InstBaseLTSBD" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") # Latest Kernel
             clear
             pacstrap ${MOUNTPOINT} base btrfs-progs ntp sudo 2>/tmp/.errlog
             ;;
        "2") # Latest Kernel and base-devel
             clear
             pacstrap ${MOUNTPOINT} base base-devel btrfs-progs ntp sudo 2>/tmp/.errlog
             ;;
        "3") # LTS Kernel
             clear
             pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs btrfs-progs ntp sudo 2>/tmp/.errlog
             [[ $? -eq 0 ]] && LTS=1
             ;;
        "4") # LTS Kernel and base-devel
             clear
             pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs base-devel btrfs-progs ntp sudo 2>/tmp/.errlog
             [[ $? -eq 0 ]] && LTS=1
             ;;
          *) install_base_menu
             ;;
    esac  	
    
    check_for_error
    

  #check for a wireless device
  if [[ $(lspci | grep -i "Network Controller") != "" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstWirTitle" --infobox "$_InstWirBody" 0 0 
     sleep 2
     clear
     pacstrap ${MOUNTPOINT} iw wireless_tools wpa_actiond wpa_supplicant dialog 2>/tmp/.errlog
     check_for_error
  fi

}

# Adapted from AIS. Integrated the configuration elements. For UEFI systems fixed the 
# gummiboot installation and dropped Syslinux.
install_bootloader() {

bios_bootloader() {	
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBiosBtTitle" \
    --menu "$_InstBiosBtBody" 0 0 2 \
 	"1" $"Grub2" \
	"2" $"Syslinux" 2>${ANSWER}
	
	case $(cat ${ANSWER}) in
        "1") clear
             pacstrap ${MOUNTPOINT} grub os-prober 2>/tmp/.errlog
             check_for_error
             
             # An LVM VG/LV can consist of multiple devices. Where LVM used, user must select the device manually.
             if [[ $LVM_ROOT -eq 1 ]]; then
                select_grub_device
             else
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstGrubDevTitle" --yesno "$_InstGrubDevBody ($INST_DEV)?$_InstGrubDevBody2" 0 0
                
                if [[ $? -eq 0 ]]; then
			       clear
			       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
                   sleep 1 
			       arch_chroot "grub-install --target=i386-pc --recheck ${INST_DEV}" 2>/tmp/.errlog
			       check_for_error
			    else   
			       select_grub_device
			    fi
			    
			 fi
                       
             arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>/tmp/.errlog
             check_for_error
             
			 # if /boot is LVM then amend /boot/grub/grub.cfg accordingly
             if ( [[ $LVM_ROOT -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]] ) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
                sed -i '/### BEGIN \/etc\/grub.d\/00_header ###/a insmod lvm' ${MOUNTPOINT}/boot/grub/grub.cfg
                #sed -i "s/set root=.*/set root=lvm/${PARTITION}/g" ${MOUNTPOINT}/boot/grub/grub.cfg
             fi
             BOOTLOADER="Grub"
             ;;
        "2") clear
             pacstrap ${MOUNTPOINT} syslinux 2>/tmp/.errlog
             arch_chroot "syslinux-install_update -iam" 2>>/tmp/.errlog
             check_for_error
             
             # Append configuration file depending on whether lvm used or not for root.
             if [[ $LVM_ROOT -eq 0 ]]; then
                sed -i "s/sda[0-9]/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             else
                sed -i "s/APPEND.*/APPEND root=\/dev\/mapper\/${ROOT_PART} rw/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             fi
             
             # If the LTS kernel has been installed amend the config file accordingly
             [[ $LTS -eq 1 ]] && sed -i 's/linux/linux-lts/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             
             if [[ $LVM_ROOT -eq 0 ]]; then
                dialog --title "$_InstSysTitle" --msgbox "$_InstSysBody APPEND root=/dev/$ROOT_PART rw\n" 0 0
             else
                dialog --title "$_InstSysTitle" --msgbox "$_InstSysBody APPEND root=/dev/mapper/$ROOT_PART rw\n" 0 0
             fi
             
             BOOTLOADER="Syslinux"
             ;;
          *) install_base_menu
             ;;
    esac  
}

uefi_bootloader() {

    #Ensure again that efivarfs is mounted
	[[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars
     
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstUefiBtTitle" \
    --menu "$_InstUefiBtBody" 0 0 3 \
    "1" $"Grub2" \
    "2" $"Gummiboot" \
    "3" $"rEFInd" 2>${ANSWER}

     case $(cat ${ANSWER}) in
     "1") # Grub2
          clear
          pacstrap ${MOUNTPOINT} grub os-prober efibootmgr dosfstools 2>/tmp/.errlog
          check_for_error
          
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
          sleep 1
          arch_chroot "grub-install --target=x86_64-efi --efi-directory=${UEFI_MOUNT} --bootloader-id=arch_grub --recheck" 2>/tmp/.errlog
          arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
          check_for_error

          # Ask if user wishes to set Grub as the default bootloader and act accordingly
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetGrubDefTitle" --yesno "$_SetGrubDefBody ${UEFI_MOUNT}/EFI/boot $_SetGrubDefBody2" 0 0
          
          if [[ $? -eq 0 ]]; then
             arch_chroot "mkdir ${UEFI_MOUNT}/EFI/boot" 2>/tmp/.errlog
             arch_chroot "cp -r ${UEFI_MOUNT}/EFI/arch_grub/grubx64.efi ${UEFI_MOUNT}/EFI/boot/bootx64.efi" 2>>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "_SetDefDoneTitle" --infobox "\nGrub $_SetDefDoneBody" 0 0
             sleep 2
          fi
          
          BOOTLOADER="Grub"
          ;;
          
     "2") # Gummiboot
          clear
          pacstrap ${MOUNTPOINT} gummiboot efibootmgr dosfstools 2>/tmp/.errlog
          arch_chroot "gummiboot --path=${UEFI_MOUNT} install" 2>>/tmp/.errlog
          check_for_error
          
          # Deal with LVM Root
          if [[ $LVM_ROOT -eq 0 ]]; then
             gummi_root=$(blkid -s PARTUUID $"/dev/"${ROOT_PART} | sed 's/.*=//g' | sed 's/"//g')
          else
             gummi_root="/dev/mapper/${ROOT_PART}"
             # $(blkid PARTUUID $"/dev/mapper/"${ROOT_PART} | awk '{print $2}' | sed 's/UUID=//' | sed 's/"//g') 
          fi
           
          # Deal with LTS Kernel
          if [[ $LTS -eq 1 ]]; then
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux-lts\ninitrd\t/initramfs-linux-lts.img\noptions\troot=PARTUUID=${gummi_root} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
          else
             echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=PARTUUID=${gummi_root} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
          fi
          
          # Fix LVM Root installations
          sed -i "s/PARTUUID=//g" ${MOUNTPOINT}/boot/loader/entries/arch.conf
          
          BOOTLOADER="Gummiboot"
          # Set the loader file  
          echo -e "default  arch\ntimeout  5" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf 2>/tmp/.errlog
          check_for_error
          ;;
          
      "3") # rEFInd
           # Ensure that UEFI partition has been mounted to /boot/efi due to bug in script. Could "fix" it for installation, but
           # This could result in unknown consequences should the script be updated at some point.
           if [[ $UEFI_MOUNT == "/boot/efi" ]]; then      
              clear
              pacstrap ${MOUNTPOINT} refind-efi efibootmgr dosfstools 2>/tmp/.errlog
              check_for_error   
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetRefiDefTitle" --yesno "$_SetRefiDefBody ${UEFI_MOUNT}/EFI/boot $_SetRefiDefBody2" 0 0
              
              if [[ $? -eq 0 ]]; then
                 clear
                 arch_chroot "refind-install --usedefault ${UEFI_PART} --alldrivers" 2>/tmp/.errlog
              else   
                 clear
                 arch_chroot "refind-install" 2>/tmp/.errlog
              fi   
              
              check_for_error
              
              # Now generate config file to pass kernel parameters. Default read only (ro) changed to read-write (rw)    
              arch_chroot "refind-mkrlconf" 2>/tmp/.errlog
              check_for_error
              sed -i 's/ro /rw /g' ${MOUNTPOINT}/boot/refind_linux.conf
              BOOTLOADER="rEFInd"
           else 
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RefiErrTitle" --msgbox "$_RefiErrBody" 0 0
              uefi_bootloader
           fi
           ;;
      
      *) install_base_menu
         ;;
      esac 

}

    check_mount
    # Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
    check_for_error

    if [[ $UEFI -eq 0 ]]; then
       bios_bootloader
    else
       uefi_bootloader
    fi
}

# Needed for broadcom and other network controllers
install_wireless_firmware() {
    
    check_mount

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelssFirmTitle" --menu "$_WirelssFirmBody" 0 0 7 \
 	"1" "$_SeeWirelessDev" \
 	"2" $"Broadcom 802.11b/g/n" \
 	"3" $"Intel PRO/Wireless 2100" \
 	"4" $"Intel PRO/Wireless 2200" \
 	"5" $"ZyDAS ZD1211(b) 802.11a/b/g USB WLAN" \
 	"6" "$_All" \
 	"7" "$_Back" 2>${ANSWER}

    case $(cat ${ANSWER}) in
    "1") # Identify the Wireless Device 
        lspci -k | grep -i -A 2 "network controller" > /tmp/.wireless
        if [[ $(cat /tmp/.wireless) != "" ]]; then
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --textbox /tmp/.wireless 0 0
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --msgbox "$_WirelessErrBody" 7 30
        fi
        ;;
    "2") # Broadcom
         clear
         pacstrap ${MOUNTPOINT} b43-fwcutter 2>/tmp/.errlog
        ;;
    "3") # Intel 2100
         clear
         pacstrap ${MOUNTPOINT} ipw2100-fw 2>/tmp/.errlog
        ;;
    "4") # Intel 2200
         clear
         pacstrap ${MOUNTPOINT} ipw2200-fw 2>/tmp/.errlog
        ;;
    "5") # ZyDAS
         clear
         pacstrap ${MOUNTPOINT} zd1211-firmware 2>/tmp/.errlog
        ;;
    "6") # All
         clear
         pacstrap ${MOUNTPOINT} b43-fwcutter ipw2100-fw ipw2200-fw zd1211-firmware 2>/tmp/.errlog
        ;;
      *) install_base_menu
        ;;
    esac
    
    check_for_error
    install_wireless_firmware

}

# Install alsa, xorg and input drivers. Also copy the xkbmap configuration file created earlier to the installed system
# This will run only once.
install_alsa_xorg_input() {

     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_AXITitle" --msgbox "$_AXIBody" 0 0
     clear	
     pacstrap ${MOUNTPOINT} alsa-utils xorg-server xorg-server-utils xorg-xinit xf86-input-synaptics xf86-input-keyboard xf86-input-mouse 2>/tmp/.errlog
     check_for_error
     
     # copy the keyboard configuration file, if generated
     [[ -e /tmp/00-keyboard.conf ]] && cp /tmp/00-keyboard.conf ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf
  
     # now copy across .xinitrc for all user accounts
     user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
	 for i in ${user_list[@]}; do
	     cp -f ${MOUNTPOINT}/etc/skel/.xinitrc ${MOUNTPOINT}/home/$i
	     arch_chroot "chown -R ${i}:users /home/${i}"
     done
     
     AXI_INSTALLED=1

}

setup_graphics_card() {

# basically this is used to manually set the GC_DETECTED variable. Includes proprietary NVIDIA drivers.
gc_driver_menu() {

   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_GCtitle" \
    --menu "$_GCBody" 0 0 10 \
 	"1" $"AMD/ATI" \
	"2" $"Intel" \
	"3" $"Nouveau (NVIDIA open-source)" \
	"4" $"NVIDIA GeForce 400 +" \
	"5" $"NVIDIA GeForce 8/9/100-300" \
	"6" $"NVIDIA GeForce 6/7" \
	"7" $"Via" \
	"8" $"VirtualBox" \
    "9" $"VMWare" \
	"10" "$_GCUnknOpt" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") GC_DETECTED="ATI"
             ;;
        "2") GC_DETECTED="Intel"
             ;;
        "3") GC_DETECTED="NVIDIA"
             ;;
        "4") GC_DETECTED="NVIDIA-GF"
             ;;
        "5") GC_DETECTED="NVIDIA-340"
             ;;
        "6") GC_DETECTED="NVIDIA-304"
             ;;              
        "7") GC_DETECTED="Via"
             ;;            
        "8") GC_DETECTED="VirtualBox"
             ;;
        "9") GC_DETECTED="VMware"
             ;;
        "10") GC_DETECTED="Generic"
             ;;
          *) install_desktop_menu
             ;;
    esac  
    install_gc
}

# Adapted from Antergos' CLI installer
detect_graphics_card() {
	
    if   [[ $(echo ${GRAPHIC_CARD} | grep -i 'ati') != "" ]]; then
         GC_DETECTED="ATI" 
    elif [[ $(echo ${GRAPHIC_CARD} | grep -i 'nvidia') != "" ]]; then
         GC_DETECTED="NVIDIA" 
    elif [[ $(echo ${GRAPHIC_CARD} | grep -i 'intel\|lenovo') != "" ]]; then
         GC_DETECTED="Intel"
    elif [[ $(echo ${GRAPHIC_CARD} | grep -i 'virtualbox') != "" ]]; then
         GC_DETECTED="VirtualBox"
    elif [[ $(echo ${GRAPHIC_CARD} | grep -i 'vmware') != "" ]]; then
         GC_DETECTED="VMware"
    elif [[ $(echo ${GRAPHIC_CARD} | grep -i 'via') != "" ]]; then
         GC_DETECTED="Via"
    else
         GC_DETECTED="Unknown"
    fi

}

install_gc() {

 clear
 
 case $GC_DETECTED in
        "ATI") pacstrap ${MOUNTPOINT} xf86-video-ati 2>/tmp/.errlog
               sed -i 's/MODULES=""/MODULES="radeon"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
               ;;
     "NVIDIA") pacstrap ${MOUNTPOINT} xf86-video-nouveau 2>/tmp/.errlog
               sed -i 's/MODULES=""/MODULES="nouveau"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
               ;;
  "NVIDIA-GF") #first remove mesa to avoid file conflicts
               arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
  
               # Now deal with kernel installed
               [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} nvidia nvidia-libgl nvidia-utils pangox-compat 2>/tmp/.errlog \
               || pacstrap ${MOUNTPOINT} nvidia-lts nvidia-libgl nvidia-utils pangox-compat 2>/tmp/.errlog
               NVIDIA_INST=1
               ;;
 "NVIDIA-340") #first remove mesa to avoid file conflicts
               arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
  
               # Now deal with kernel installed
               [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} nvidia-340xx nvidia-340xx-libgl nvidia-340xx-utils 2>/tmp/.errlog \
               || pacstrap ${MOUNTPOINT} nvidia-340xx-lts nvidia-340xx-libgl nvidia-340xx-utils 2>/tmp/.errlog
               NVIDIA_INST=1
               ;;
 "NVIDIA-304") #first remove mesa to avoid file conflicts
               arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
 
               # Now deal with kernel installed
               [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} nvidia-304xx nvidia-304xx-libgl nvidia-304xx-utils 2>/tmp/.errlog \
               || pacstrap ${MOUNTPOINT}  nvidia-304xx-lts nvidia-304xx-libgl nvidia-304xx-utils 2>/tmp/.errlog
               NVIDIA_INST=1
               ;;
      "Intel") pacstrap ${MOUNTPOINT} xf86-video-intel libva-intel-driver intel-ucode 2>/tmp/.errlog
               sed -i 's/MODULES=""/MODULES="i915"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
               
               # Intel microcode (Syslinux and Gummiboot).
               # Grub automatically deals with this. rEFInd is yet to be added.
               case $BOOTLADER in
				    "Syslinux") sed -i 's/INITRD /INITRD/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
                                sed -i 's/INITRD/INITRD ..\/intel-ucode.img,/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
                                ;;
                   "Gummiboot") sed -i '/linux \//a initrd \/intel-ucode.img' ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
                                ;;
               esac
               ;;
 "VirtualBox") dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_VBoxInstTitle" --msgbox "$_VBoxInstBody" 0 0
               clear
               [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules 2>/tmp/.errlog \
               || pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules-lts 2>/tmp/.errlog
      
               # Load modules and enable vboxservice whatever the kernel
               arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"  
               arch_chroot "systemctl enable vboxservice"
               ;;
     "VMWare") pacstrap ${MOUNTPOINT} xf86-video-vmware xf86-input-vmmouse 2>/tmp/.errlog
               ;;
        "Via") pacstrap ${MOUNTPOINT} xf86-video-openchrome 2>/tmp/.errlog
               ;;
    "Generic") pacstrap ${MOUNTPOINT} xf86-video-modesetting 2>/tmp/.errlog
               ;;
            *) gc_driver_menu  
               ;;
 esac

 check_for_error

 # Create a basic xorg configuration file for NVIDIA proprietary drivers where installed
 # if that file does not already exist.
 if [[ $NVIDIA_INST == 1 ]] && [[ ! -e ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf ]]; then
    echo "Section "\"Device"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Identifier "\"Nvidia Card"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Driver "\"nvidia"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        VendorName "\"NVIDIA Corporation"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Option "\"NoLogo"\" "\"true"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        #Option "\"UseEDID"\" "\"false"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        #Option "\"ConnectedMonitor"\" "\"DFP"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        # ..." >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "EndSection" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
 fi
 
 # Where NVIDIA has been installed allow user to check and amend the file
 if [[ $NVIDIA_INST == 1 ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NvidiaConfTitle" --msgbox "$_NvidiaConfBody" 0 0
    leafpad ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf >/dev/null 2>&1
 fi

}

    detect_graphics_card
    if [[ $GC_DETECTED == "Unknown" ]]; then
       gc_driver_menu
    else
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $GC_DETECTED $_GCDetTitle " --yesno "$_GCDetBody $GC_DETECTED?\n\n $_GCDetBody2" 0 0 && install_gc || gc_driver_menu
    fi

}


install_de_wm() {

   # Only show this information box once
   if [[ $SHOW_ONCE -eq 0 ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DEInfoTitle" --msgbox "$_DEInfoBody" 0 0
      SHOW_ONCE=1
   fi
   
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDETitle" \
    --menu "$_InstDEBody" 0 0 8 \
 	"1" $"Cinnamon" \
	"2" $"Enlightenment" \
	"3" $"Gnome-Shell (minimal)" \
	"4" $"Gnome" \
	"5" $"Gnome + Extras" \
    "6" $"KDE4 Base (minimal)" \
    "7" $"KDE4" \
    "8" $"LXDE" \
    "9" $"MATE" \
    "10" $"MATE + Extras" \
    "11" $"Xfce" \
    "12" $"Xfce + extras" \
    "13" $"Awesome WM" \
    "14" $"Fluxbox WM" \
	"15" $"i3 WM" \
    "16" $"Ice WM" \
    "17" $"Openbox WM" \
    "18" $"Openbox + Evo (EvoBox)" \
    "19" $"Pek WM" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") # Cinnamon
             clear
             pacstrap ${MOUNTPOINT} cinnamon 2>/tmp/.errlog
             ;;
        "2") # Enlightement
             clear
             pacstrap ${MOUNTPOINT} enlightenment terminology polkit-gnome 2>/tmp/.errlog
             ;;
        "3") # Gnome-Shell
             clear
             pacstrap ${MOUNTPOINT} gnome-shell gdm 2>/tmp/.errlog
             GNOME_INSTALLED=1
             ;;
        "4") # Gnome
             clear
             pacstrap ${MOUNTPOINT} gnome rp-pppoe 2>/tmp/.errlog

             if [[ $NM_INSTALLED -eq 0 ]]; then         
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
                NM_INSTALLED=1
             fi
           
             GNOME_INSTALLED=1
             ;;            
        "5") # Gnome + Extras
             clear
             pacstrap ${MOUNTPOINT} gnome gnome-extra rp-pppoe 2>/tmp/.errlog

             if [[ $NM_INSTALLED -eq 0 ]]; then         
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
                NM_INSTALLED=1
             fi
           
             GNOME_INSTALLED=1
             ;;
        "6") # KDE4 BASE
             clear
             pacstrap ${MOUNTPOINT} kdebase-workspace kdeplasma-applets-plasma-nm xdg-utils rp-pppoe 2>/tmp/.errlog
             KDE_INSTALLED=1
             ;;
        "7") # KDE4 
             clear
             pacstrap ${MOUNTPOINT} kde kdeplasma-applets-plasma-nm xdg-user-dirs xdg-utils rp-pppoe 2>/tmp/.errlog

             if [[ $NM_INSTALLED -eq 0 ]]; then          
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
                NM_INSTALLED=1
             fi
               
             KDE_INSTALLED=1
             ;;
         "8") # LXDE
              clear
              pacstrap ${MOUNTPOINT} lxde 2>/tmp/.errlog
              LXDE_INSTALLED=1
             ;;
         "9") # MATE
              clear
              pacstrap ${MOUNTPOINT} mate 2>/tmp/.errlog
             ;;
        "10") # MATE + Extras
               clear
               pacstrap ${MOUNTPOINT} mate mate-extra 2>/tmp/.errlog
             ;;                 
        "11") # Xfce
              clear
              pacstrap ${MOUNTPOINT} xfce4 polkit-gnome 2>/tmp/.errlog
             ;;            
        "12") # Xfce + Extras
              clear
              pacstrap ${MOUNTPOINT} xfce4 xfce4-goodies polkit-gnome 2>/tmp/.errlog
             ;;
        "13") # Awesome
              clear
              pacstrap ${MOUNTPOINT} awesome vicious polkit-gnome 2>/tmp/.errlog
             ;;
        "14") #Fluxbox
              clear 
              pacstrap ${MOUNTPOINT} fluxbox fbnews fluxter polkit-gnome 2>/tmp/.errlog
             ;; 
        "15") #i3
              clear
              pacstrap ${MOUNTPOINT} i3-wm i3lock i3status dmenu polkit-gnome 2>/tmp/.errlog
             ;; 
        "16") #IceWM
              clear
              pacstrap ${MOUNTPOINT} icewm icewm-themes polkit-gnome 2>/tmp/.errlog
             ;; 
        "17") #Openbox
              clear
              pacstrap ${MOUNTPOINT} openbox openbox-themes polkit-gnome 2>/tmp/.errlog
             ;; 
        "18") #EvoBox
              
              # Pick File Manager
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " EvoBox File Manager " \
              --menu "" 9 0 3 \
 	          "1" $"PCManFM" \
	          "2" $"SpaceFM" \
	          "3" $"Thunar" 2>${ANSWER}
	
              case $(cat ${ANSWER}) in
				"1") EVOBOXFM="pcmanfm" 
                     ;;
				"2") EVOBOXFM="spacefm"
					 ;;
				"3") EVOBOXFM="thunar"
					 ;;
				  *) install_de_wm
					 ;;            
			  esac
			  
			  # Pick Internet Browser
			  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " EvoBox Browser " \
			  --menu "" 11 0 5 \
			  "1" $"Chromium" \
			  "2" $"FireFox" \
			  "3" $"Midori" \
			  "4" $"Netsurf" \
			  "5" $"Opera" 2>${ANSWER}
	
			  case $(cat ${ANSWER}) in
				"1") EVOBOXIB="chromium" 
					 ;;
				"2") EVOBOXIB="firefox"
					 ;;
				"3") EVOBOXIB="midori"
					 ;;
				"4") EVOBOXIB="netsurf"
					 ;;
				"5") EVOBOXIB="opera"
					 ;;
				  *) install_de_wm
					 ;;            
			  esac
			  			  
              clear
              pacstrap ${MOUNTPOINT} openbox oblogout openbox-themes numix-themes xcursor-vanilla-dmz tint2 conky libgnomeui obconf lxappearance-obconf lxinput lxrandr lxterminal volumeicon gnome-alsamixer dmenu xlockmore flashplugin polkit-gnome ${EVOBOXFM} ${EVOBOXIB} 2>/tmp/.errlog
              
              cp -f $SCRIPT_DIR/evobox/oblogout.conf ${MOUNTPOINT}/etc
              cp -f $SCRIPT_DIR/evobox/.gtkrc-2.0 ${MOUNTPOINT}/root
              sed -i "s/evo/root/" ${MOUNTPOINT}/root/.gtkrc-2.0
              
              user_list=""
              user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
		      for i in ${user_list[@]}; do
				[[ -n ${MOUNTPOINT}/home/$i/.config/openbox ]] && mkdir -p ${MOUNTPOINT}/home/$i/.config/openbox
				[[ -n ${MOUNTPOINT}/home/$i/.config/tint2 ]] && mkdir -p ${MOUNTPOINT}/home/$i/.config/tint2
				[[ -n ${MOUNTPOINT}/home/$i/.config/gtk-3.0 ]] && mkdir -p ${MOUNTPOINT}/home/$i/.config/gtk-3.0
				[[ -n ${MOUNTPOINT}/home/$i/.config/volumeicon ]] && mkdir -p ${MOUNTPOINT}/home/$i/.config/volumeicon
				
				cp -f $SCRIPT_DIR/evobox/.conkyrc ${MOUNTPOINT}/home/$i
				cp -f $SCRIPT_DIR/evobox/.gtkrc-2.0 ${MOUNTPOINT}/home/$i
				cp -f $SCRIPT_DIR/evobox/settings.ini ${MOUNTPOINT}/home/$i/.config/gtk-3.0
				cp -f $SCRIPT_DIR/evobox/tint2rc ${MOUNTPOINT}/home/$i/.config/tint2
				cp -f $SCRIPT_DIR/evobox/volumeicon ${MOUNTPOINT}/home/$i/.config/volumeicon
				cp -f $SCRIPT_DIR/evobox/autostart ${MOUNTPOINT}/home/$i/.config/openbox
				cp -f $SCRIPT_DIR/evobox/environment ${MOUNTPOINT}/home/$i/.config/openbox
				cp -f $SCRIPT_DIR/evobox/menu.xml ${MOUNTPOINT}/home/$i/.config/openbox
				cp -f $SCRIPT_DIR/evobox/rc.xml ${MOUNTPOINT}/home/$i/.config/openbox
				
				sed -i "s/evo/${i}/" ${MOUNTPOINT}/home/$i/.gtkrc-2.0
				sed -i "s/thunar/${EVOBOXFM}/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.config/openbox/rc.xml
				sed -i "s/firefox/${EVOBOXIB}/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.config/openbox/rc.xml
				
				[[ $EVOBOXFM == "pcmanfm" ]] && sed -i "s/Thunar/PCManFM/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc
				[[ $EVOBOXFM == "spacefm" ]] && sed -i "s/Thunar/SpaceFM/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc
				[[ $EVOBOXIB == "chromium" ]] && sed -i "s/Firefox/Chromium/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc
				[[ $EVOBOXIB == "midori" ]] && sed -i "s/Firefox/Midori/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc
				[[ $EVOBOXIB == "netsurf" ]] && sed -i "s/Firefox/Netsurf/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc
				[[ $EVOBOXIB == "opera" ]] && sed -i "s/Firefox/Opera/" ${MOUNTPOINT}/home/$i/.config/openbox/menu.xml ${MOUNTPOINT}/home/$i/.conkyrc

				arch_chroot "chown -R ${i}:users /home/${i}"
              done
             ;;
        "19") #PekWM
              clear
              pacstrap ${MOUNTPOINT} pekwm pekwm-themes polkit-gnome 2>/tmp/.errlog
             ;;            
          *) install_desktop_menu
             ;;
    esac  
    
    check_for_error
    
    # Offer to install common packages
    if [[ $COMMON_INSTALLED -eq 0 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstComTitle" --yesno "$_InstComBody" 0 0
       
       if [[ $? -eq 0 ]]; then
          clear
          pacstrap ${MOUNTPOINT} xterm gksu gnome-keyring polkit xdg-user-dirs xdg-utils gamin gvfs gvfs-afc gvfs-smb ttf-dejavu gnome-icon-theme python2-xdg bash-completion ntfs-3g 2>/tmp/.errlog
          check_for_error
       fi
       
    fi
    
    # Either way, the option will no longer be presented.
    COMMON_INSTALLED=1

}

# Determine if LXDE, Gnome, and/or KDE has been installed, and act accordingly.
install_dm() {

 if [[ $DM_INSTALLED -eq 0 ]]; then
	
          if  [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 0 ]]; then
               arch_chroot "systemctl enable kdm.service" >/dev/null 2>/tmp/.errlog
               check_for_error
               dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmKdeTitle" --msgbox "$_DmKdeBody" 0 0
         elif  [[ $KDE_INSTALLED -eq 0 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
               arch_chroot "systemctl enable gdm.service" >/dev/null 2>/tmp/.errlog
               check_for_error
               dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmGdmTitle" --msgbox "$_DmGdmBody" 0 0
         elif  [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
         
               dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" \
               --menu "$_DmChBody" 12 45 2 \
 	           "1" $"GDM (Gnome)" \
	           "2" $"KDM (KDE)" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") arch_chroot "systemctl enable gdm.service" >/dev/null 2>/tmp/.errlog
                   DM="GDM"
                ;;
              "2") arch_chroot "systemctl enable kdm.service" >/dev/null 2>/tmp/.errlog
                   DM="KDM"
                ;;
                *) install_desktop_menu
                ;;
              esac 
              
              check_for_error
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $DM $_DmDoneTitle" --msgbox "\n$DM $_DMDoneBody" 0 0
              
         elif [[ $LXDE_INSTALLED -eq 1 ]]; then
              arch_chroot "systemctl enable lxdm.service" >/dev/null 2>/tmp/.errlog
              check_for_error
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmLxdmTitle" --msgbox "$_DmLxdmBody" 0 0
              DM="LXDM"
         else 
               dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChoiceTitle" \
               --menu "$_DmChoiceBody" 0 0 4 \
 	           "1" $"LXDM" \
	           "2" $"LightDM" \
	           "3" $"SDDM" \
	           "4" $"SLiM" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") # LXDM
                   clear
                   pacstrap ${MOUNTPOINT} lxdm 2>/tmp/.errlog
                   arch_chroot "systemctl enable lxdm.service" >/dev/null 2>>/tmp/.errlog
                   DM="LXDM"
                   ;;
              "2") # LIGHTDM
                   clear
                   pacstrap ${MOUNTPOINT} lightdm lightdm-gtk3-greeter 2>/tmp/.errlog
                   arch_chroot "systemctl enable lightdm.service" >/dev/null 2>>/tmp/.errlog
                   DM="LightDM"
                   ;;
              "3") # SDDM
                   clear
                   pacstrap ${MOUNTPOINT} sddm 2>/tmp/.errlog
                   arch_chroot "sddm --example-config > /etc/sddm.conf"
                   arch_chroot "systemctl enable sddm.service" >/dev/null 2>>/tmp/.errlog
                   DM="SDDM"
                   ;;
              "4") # SLiM
                   clear
                   pacstrap ${MOUNTPOINT} slim 2>/tmp/.errlog
                   arch_chroot "systemctl enable slim.service" >/dev/null 2>>/tmp/.errlog
                   DM="SLiM"

                   # Amend the xinitrc file accordingly for all user accounts
                   user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
				   for i in ${user_list[@]}; do
                       if [[ -n ${MOUNTPOINT}/home/$i/.xinitrc ]]; then
                          cp -f ${MOUNTPOINT}/etc/skel/.xinitrc ${MOUNTPOINT}/home/$i
	                      arch_chroot "chown -R ${i}:users /home/${i}"
	                   fi
                       echo 'exec $1' >> ${MOUNTPOINT}/home/$i/.xinitrc
                   done
                
                   ;;                
                *) install_desktop_menu
                   ;;
              esac
              
              check_for_error
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $DM $_DmDoneTitle" --msgbox "\n$DM $_DMDoneBody" 0 0
         fi
         
         # Ensure DM option can only be run once where one has been installed.
         DM_INSTALLED=1
         
   # if A display manager has already been installed and enabled (DM_INSTALLED=1), show a message instead.
   else  
         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmInstTitle" --msgbox "$_DmInstBody" 0 0
   fi       

}

install_nm() {
   # Check to see if a NM has already been installed and enabled
   if [[ $NM_INSTALLED -eq 0 ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMTitle" \
      --menu "$_InstNMBody" 0 0 4 \
 	  "1" $"Connman (CLI)" \
	  "2" $"dhcpcd  (CLI)" \
	  "3" $"Network Manager (GUI)" \
	  "4" $"WICD (GUI)" 2>${ANSWER}	
	
	  case $(cat ${ANSWER}) in
      "1") # connman
           clear
           pacstrap ${MOUNTPOINT} connman 2>/tmp/.errlog
           arch_chroot "systemctl enable connman.service" 2>>/tmp/.errlog
           ;;
      "2") # dhcpcd
           clear
           arch_chroot "systemctl enable dhcpcd.service" 2>/tmp/.errlog
           ;;
      "3") # Network Manager
           clear
           pacstrap ${MOUNTPOINT} networkmanager network-manager-applet rp-pppoe 2>/tmp/.errlog
           arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
           ;;
      "4") # WICD
           clear
           pacstrap ${MOUNTPOINT} wicd-gtk 2>/tmp/.errlog
           arch_chroot "systemctl enable wicd.service" 2>>/tmp/.errlog
           ;;
        *) install_desktop_menu
           ;;
      esac
      
      check_for_error
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMDoneTitle" --msgbox "$_InstNMDoneBody" 0 0
      NM_INSTALLED=1
   
   else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMDoneTitle" --msgbox "$_InstNMErrBody" 0 0
   fi
}


test() {
	
	ping -c 3 google.com > /tmp/.outfile &
    dialog --title "checking" --no-kill --tailboxbg /tmp/.outfile 20 60 

}
	


######################################################################
##																	##
##                 Main Interfaces       							##
##																	##
######################################################################

# Greet the user when first starting the installer
greeting() {

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WelTitle $VERSION " --msgbox "$_WelBody" 0 0	

}

# Preparation
prep_menu() {
	
	if [[ $SUB_MENU != "prep_menu" ]]; then
	   SUB_MENU="prep_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PrepTitle" \
    --menu "$_PrepBody" 0 0 7 \
 	"1" "$_PrepKBLayout" \
	"2" "$_PrepMirror" \
	"3" "$_DevShowOpt" \
	"4" "$_PrepPartDisk" \
	"5" "$_PrepLVM" \
	"6" "$_PrepMntPart" \
	"7" "$_Back" 2>${ANSWER}

    HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") set_xkbmap 
             ;;
        "2") configure_mirrorlist
             ;;
        "3") show_devices
             ;;
        "4") umount_partitions
             select_device
             create_partitions
             ;;
        "5") detect_lvm
             deactivate_lvm
             find_lvm_partitions
             create_lvm
             ;;
        "6") mount_partitions
             ;;        
          *) main_menu_online
             ;;
    esac
    
    prep_menu  	
	
}

# Base Installation
install_base_menu() {

	if [[ $SUB_MENU != "install_base_menu" ]]; then
	   SUB_MENU="install_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBsMenuTitle" --menu "$_InstBseMenuBody" 0 0 5 \
 	"1" "$_PrepPacKey" \
 	"2" "$_InstBse" \
	"3" "$_InstBootldr" \
	"4" "$_InstWirelessFirm" \
	"5" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") clear
             pacman-key --init
             pacman-key --populate archlinux
             pacman-key --refresh-keys
             ;;
        "2") install_base
             ;;
        "3") install_bootloader
             ;;
        "4") install_wireless_firmware
             ;;
          *) main_menu_online
             ;;
     esac
    
    install_base_menu 	
}

# Base Configuration
config_base_menu() {
	
	# Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
	check_for_error
	
	if [[ $SUB_MENU != "config_base_menu" ]]; then
	   SUB_MENU="config_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfBseTitle" --menu "$_ConfBseBody" 0 0 7 \
 	"1" "$_ConfBseFstab" \
	"2" "$_ConfBseHost" \
	"3" "$_ConfBseTime" \
	"4" "$_ConfBseHWC" \
	"5" "$_ConfBseSysLoc" \
	"6" "$_ConfBseVirtCon" \
	"7" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") generate_fstab 
             ;;
        "2") set_hostname
             ;;
        "3") set_timezone
             ;;
        "4") set_hw_clock
             ;;            
        "5") set_locale
             ;;
        "6") set_keymap
             ;;            
          *) main_menu_online
             ;;
    esac
    
    config_base_menu

}

# Root and User Configuration
config_user_menu() {

	if [[ $SUB_MENU != "config_user_menu" ]]; then
	   SUB_MENU="config_user_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 3 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfUsrTitle" --menu "$_ConfUsrBody" 0 0 3 \
 	"1" "$_ConfUsrRoot" \
	"2" "$_ConfUsrNew" \
	"3" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") set_root_password 
         ;;
    "2") create_new_user
         ;;     
      *) main_menu_online
         ;;
    esac
    
    config_user_menu
}


install_desktop_menu() {

	if [[ $SUB_MENU != "install_deskop_menu" ]]; then
	   SUB_MENU="install_deskop_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDEMenuTitle" --menu "$_InstDEMenuBody" 0 0 5 \
 	"1" "$_InstDEMenuGISD" \
	"2" "$_InstDEMenuDE" \
	"3" "$_InstDEMenuNM" \
	"4" "$_InstDEMenuDM" \
	"5" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") [[ AXI_INSTALLED -eq 0 ]] && install_alsa_xorg_input
             setup_graphics_card 
             ;;
        "2") install_de_wm
             ;;
        "3") install_nm
             ;;
        "4") install_dm
             ;;            
          *) main_menu_online
             ;;
    esac
    
    install_desktop_menu
	
}

edit_configs() {
	
	# Clear the file variables
	FILE=""
	FILE2=""
	user_list=""
	
	if [[ $SUB_MENU != "edit configs" ]]; then
	   SUB_MENU="edit configs"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 9 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfOptTitle" --menu "$_SeeConfOptBody" 0 0 10 \
   "1" "vconsole.conf" \
   "2" "locale.conf" \
   "3" "hostname & hosts" \
   "4" "sudoers" \
   "5" "mkinitcpio.conf" \
   "6" ".xinitrc" \
   "7" "fstab" \
   "8" "$BOOTLOADER" \
   "9" "$DM" \
   "10" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
	    "1") FILE="${MOUNTPOINT}/etc/vconsole.conf"
             ;;
        "2") FILE="${MOUNTPOINT}/etc/locale.conf" 
             ;;
        "3") FILE="${MOUNTPOINT}/etc/hostname"
             FILE2="${MOUNTPOINT}/etc/hosts"
             ;;
        "4") FILE="${MOUNTPOINT}/etc/sudoers"
             ;;
        "5") FILE="${MOUNTPOINT}/etc/mkinitcpio.conf"
             ;;
        "6")  user_list=""
              user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
				   for i in ${user_list[@]}; do
                       if [[ -e ${MOUNTPOINT}/home/$i/.xinitrc ]]; then
                          gksu leafpad ${MOUNTPOINT}/home/$i/.xinitrc >/dev/null 2>&1
	                   else
	                      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$__SeeConfErrTitle" --msgbox "$_SeeConfErrBody1" 0 0
	                      break;
                       fi
                   done
             ;;
        "7") FILE="${MOUNTPOINT}/etc/fstab"
             ;;
        "8") case $BOOTLOADER in
                   "Grub") FILE="${MOUNTPOINT}/etc/default/grub"
                           ;;
               "Syslinux") FILE="${MOUNTPOINT}/boot/syslinux/syslinux.cfg"
                           ;;
              "Gummiboot") FILE="${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf" 
                           FILE2="${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf"
                           ;;
                 "rEFInd") [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf ]] \
                           && FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf" || FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/BOOT/refind.conf"
                           FILE2="${MOUNTPOINT}/boot/refind_linux.conf"
                           ;;
              esac
            ;;
        "9") case $DM in
                   "LXDM") FILE="${MOUNTPOINT}/etc/lxdm/lxdm.conf" 
                           ;;
                "LightDM") FILE="${MOUNTPOINT}/etc/lightdm/lightdm.conf" 
                           ;;
                   "SDDM") FILE="${MOUNTPOINT}/etc/sddm.conf"
                           ;;
                   "SLiM") FILE="${MOUNTPOINT}/etc/slim.conf"
                           ;;
              esac
            ;;       
         *) main_menu_online
            ;;
     esac
     
     # There could be more than one .xinitrc file, so do not open it here.
     if [[ $HIGHLIGHT_SUB != 6 ]]; then
        
        if [[ -e $FILE ]] && [[ $FILE2 != "" ]]; then
           leafpad $FILE & leafpad $FILE2
        elif [[ -e $FILE ]]; then 
           leafpad $FILE
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfErrTitle" --msgbox "$_SeeConfErrBody1" 0 0
        fi
        
     fi
     
     edit_configs
}

main_menu_online() {
	
	if [[ $HIGHLIGHT != 8 ]]; then
	   HIGHLIGHT=$(( HIGHLIGHT + 1 ))
	fi
	
    dialog --default-item ${HIGHLIGHT} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MMTitle" \
    --menu "$_MMBody" 0 0 8 \
 	"1" "$_MMPrep" \
	"2" "$_MMInstBse" \
	"3" "$_MMConfBse" \
	"4" "$_MMConfUsr" \
	"5" "$_MMInstDE" \
    "6" "$_MMRunMkinit" \
    "7" "$_SeeConfOpt" \
	"8" "$_Done" 2>${ANSWER}

    HIGHLIGHT=$(cat ${ANSWER})
    
    # Depending on the answer, first check whether partition(s) are mounted and whether base has been installed
    if [[ $(cat ${ANSWER}) -eq 2 ]]; then
       check_mount
    fi

    if [[ $(cat ${ANSWER}) -ge 3 ]] && [[ $(cat ${ANSWER}) -le 7 ]]; then
       check_mount
       check_base
    fi
    
    case $(cat ${ANSWER}) in
        "1") prep_menu 
             ;;
        "2") install_base_menu
             ;;
        "3") config_base_menu
             ;;
        "4") config_user_menu
             ;;            
        "5") install_desktop_menu
             ;;
        "6") run_mkinitcpio
             ;;
        "7") edit_configs
             ;;            
          *) dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_CloseInstBody" 0 0
          
             if [[ $? -eq 0 ]]; then
                umount_partitions
                clear
                exit 0
             else
                main_menu_online
             fi
             
             ;;
    esac
    
    main_menu_online 
    
}

######################################################################
##																	##
##                        Execution     							##
##																	##
######################################################################
id_system
select_language
check_evo_requirements
greeting

	while true; do
          main_menu_online      
    done
